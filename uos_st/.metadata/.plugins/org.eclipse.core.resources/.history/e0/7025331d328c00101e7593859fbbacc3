/*
 * uos_port.c
 *
 *  Created on: Sep 7, 2025
 *      Author: pedro-bittencourt
 */

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#include "utl_lst.h"
#include "uos.h"
#include "uos_port.h"
#include "main.h"

#define OS_PORT_TIMER_PRIO 5
#define OS_PORT_SCHED_PRIO 5

static void (*timer_cbk)(void) = 0;
static uos_tcb_t* (*context_switch_cbk)(void) = 0;
static uint32_t ticks_per_second = 0;
static uos_tcb_t *current_tcb;

uint32_t uos_port_critical_section_enter(void)
{

}

void uos_port_critical_section_leave(uint32_t state)
{
    // implementation specific to the platform
}

void SysTick_Handler(void)
{
    static uint32_t tick_cnt = 0;

    if(++tick_cnt >= ticks_per_second)
    {
        tick_cnt = 0;
        if(timer_cbk)
            timer_cbk();
    }
}

__attribute__((naked))
void SVC_Handler(void)
{
    __asm volatile (
        "tst lr, #4             \n" // descobre qual pilha esta sendo usada e salva em r0
        "ite eq                 \n"
        "mrseq r4, msp          \n"
        "mrsne r4, psp          \n"
       	"ldr r0, [r4, #0]       \n" // svc number
    	"ldr r1, [r4, #4]       \n" // primeiro argumento
    	"ldr r2, [r4, #8]       \n" // segundo argumento
		"ldr r3, [r4, #12]      \n" // terceiro argumento
		"cmp r0, #0             \n" // testa se svc == 0 (start kernel)
		"bne svc_services       \n"
    	"msr msp, r1            \n" // pilha em r1
    	"pop {r4-r11}           \n"
    	"str r2, [r1,#0]        \n" // argumento da tarefa em r2
    	"bx lr                  \n"
    	"svc_services:		    \n"
    	"push {lr}              \n" // salva o lr
        "bl uos_syscall_handler \n"
    	"pop {lr}               \n" // restaura o lr
    	"str r0, [r4, #0]       \n" // salva valor de retorno na pilha
    	"bx lr                  \n"
    );
}

uint32_t uos_port_syscall(uos_syscalls_t syscall, uint32_t arg1, uint32_t arg2, uint32_t arg3)
{
	uint32_t ret;

	__asm volatile (
		"mov r0, %1      \n"
		"mov r1, %2      \n"
		"mov r2, %3      \n"
		"mov r3, %4      \n"
		"svc 0           \n"
		"mov %0, r0      \n"
		: "=r" (ret)
		: "r" (syscall), "r" (arg1), "r" (arg2), "r" (arg3)
		: "r0", "r1", "r2", "r3"
	);

	return ret;
}

// TODO consider float point stack !
// TODO consider multiple stacks usage (msp and psp)

__attribute__((naked))
void PendSV_Handler(void)
{
	// save r4-r11
	__asm volatile ("push {r4-r11}");
	// save sp in current_tcb->stack_pointer
	__asm volatile ("mov %0, sp" : "=r"(current_tcb->stack_pointer) :: "r0");

	if(context_switch_cbk)
	{
		__asm volatile ("push {lr}");
		current_tcb = context_switch_cbk();
		__asm volatile ("pop {lr}");
	}
	__asm volatile ("dsb");
	__asm volatile ("isb");

	// retrieve tcb->stack_pointer from current_tcb and save on r0
	__asm volatile ("mov r0, %0" :: "r"(current_tcb->stack_pointer) : "r0");
	// set stack pointer as the current stack pointer
	__asm volatile("msr msp, r0\n");
	// restore r4-r11
	__asm volatile ("pop {r4-r11}");
	// return from exception
	__asm volatile ("bx lr");
}

void uos_port_task_stack_init(uos_tcb_t *tcb)
{
    // round stack size to a word boundary
    if((uint32_t)tcb->stack_area & 0x03)
    {
        tcb->stack_area = (uintptr_t *)((uintptr_t)tcb->stack_area & ~0x03) + 4;
        tcb->stack_size_in_words -= 1;
    }

    // stack operations are always downwards (decrement and set)
    tcb->stack_pointer = tcb->stack_area + tcb->stack_size_in_words;

    // standard interrupt context for cortex M
    uintptr_t *sp = tcb->stack_pointer;
    *(--sp) = 0x01000000; // xPSR with thumb bit set
    *(--sp) = (uint32_t) tcb->task_entry; // pc
    *(--sp) = 0xFFFFFFF9; // lr
    *(--sp) = 0; // r12
    *(--sp) = 0; // r3
    *(--sp) = 0; // r2
    *(--sp) = 0; // r1
    *(--sp) = (uint32_t) tcb->arg; // r0, task argument

    // r4-r11
    for(size_t pos = 0; pos < 8; pos++)
        *(--sp) = 0;

    tcb->stack_pointer = sp;
}

void uos_port_timer_configure(uint32_t ticks_per_second, void (*cbk)(void))
{
    // configure a 1ms systick or platform specific timer
	HAL_SYSTICK_Config(SystemCoreClock/ticks_per_second);
	HAL_NVIC_SetPriority(SysTick_IRQn, OS_PORT_TIMER_PRIO, 0U);

    ticks_per_second = ticks_per_second;
    timer_cbk = cbk;
}

void uos_port_context_switch_configure(uos_tcb_t* (*cbk)(void))
{
    // configure pendsv
	HAL_NVIC_SetPriority(PendSV_IRQn, OS_PORT_SCHED_PRIO, 0);
    context_switch_cbk = cbk;
}

inline void uos_port_context_switch_trigger(void)
{
    // trigger pendsv
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
}

void uos_port_context_save(uos_tcb_t *tcb)
{
    // implementation specific to the platform
}

void uos_port_context_restore(uos_tcb_t *tcb)
{
    // implementation specific to the platform

	// set the stack pointer to the task's stack pointer
	__set_MSP((uint32_t)tcb->stack_pointer);
}

void uos_port_first_task_schedule(uos_tcb_t *tcb)
{
	current_tcb = tcb;
    uos_port_syscall(UOS_SYSCALL_START_KERNEL,
    		(uint32_t) tcb->stack_pointer,
    		(uint32_t) tcb->arg,
			0);
}
